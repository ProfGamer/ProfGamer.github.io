[{"content":"Spring Security 6 1.向pom中导入所需依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2.如何修改默认的用户名和密码 在application.yml中配置security相关属性\n1 2 3 4 5 spring: security: user: name: admin password: password 3. Spring security internal flow overview Spring Security过滤器：一系列过滤器拦截每一个请求，确定是否需要认证。如果需要认证，会引导用户到登录页面或使用初始化认证时存储的详细信息。 认证对象（Authentication）：像UsernamePasswordAuthenticationFilter这样的过滤器从HTTP请求中提取用户名和密码，并准备认证类型对象。认证是Spring Security框架存储认证用户详细信息的核心标准。 认证管理器（AuthenticationManager）：过滤器接收到请求后，它会将用户详细信息的验证委托给可用的认证提供器。由于一个应用中可以有多个提供器，认证管理器负责管理所有可用的认证提供器。 认证提供器（AuthenticationProvider）：认证提供器包含验证用户详细信息以进行认证的所有核心逻辑。 用户详细信息管理器/服务（UserDetailsManager/UserDetailsService）：帮助检索、创建、更新、删除数据库或存储系统中的用户详细信息。 密码编码器（PasswordEncoder）：服务接口，帮助对密码进行编码和哈希处理。否则我们可能不得不处理明文密码。 安全上下文（SecurityContext）：请求一旦通过认证，认证信息通常会存储在由SecurityContextHolder管理的线程局部SecurityContext中。这在相同用户的后续请求中非常有用。 4. Spring Security中一些重要的过滤器 Filters AuthorizationFilter\nDefaultLoginPageGeneratingFilter\nUsernamePasswordAuthenticationFilter\nDefault Sequence Flow\n用户尝试首次访问一个安全页面。 在后台，过滤器如AuthorizationFilter、DefaultLoginPageGeneratingFilter会识别用户未登录，并引导用户前往登录页面。 用户输入了凭证，并且请求被过滤器拦截。 过滤器如UsernamePasswordAuthenticationFilter从请求中提取用户名和密码，并形成一个UsernamePasswordAuthenticationToken对象。 ProviderManager，作为AuthenticationManager的实现，识别出支持给定认证对象风格的认证提供者列表。在默认行为中，authenticate()方法将调用DaoAuthenticationProvider。 DaoAuthenticationProvider调用InMemoryUserDetailsManager的loadUserByUsername()方法，从内存中加载用户详细信息。加载用户详细信息后，它将借助默认的密码编码器实现来比较密码，并验证用户是否通过认证。 最后，它返回认证对象，包含认证成功与否的详情，给ProviderManager。 ProviderManager检查认证是否成功。如果不成功，它将尝试其他可用的AuthenticationProviders。否则，它简单地返回认证详情给过滤器。 认证对象被过滤器存储在SecurityContext对象中，以便后续使用，并且响应将返回给最终用户 5. Spring security 如何处理已登录用户的多个请求 默认行为 -\u0026gt; 之后可以使用更高级的概念 JWT OAUTH2\n将JSESSIONID存入浏览器本地Cookie中, 同一已登录用户的每次请求所携带的JSESSIONID是相同的,\n每次登录Spring Security都会为该浏览器生成一个新的JSESSIONID Cookie\n6. Spring Security的默认设置 在SpringBootWEbSecurityCOnfiguration这个配置类中的defaultSecurityFilterChain方法中定义了默认的安全行为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * The default configuration for web security. It relies on Spring Security\u0026#39;s * content-negotiation strategy to determine what sort of authentication to use. If * the user specifies their own {@link SecurityFilterChain} bean, this will back-off * completely and the users should specify all the bits that they want to configure as * part of the custom security configuration. */ @Configuration(proxyBeanMethods = false) @ConditionalOnDefaultWebSecurity static class SecurityFilterChainConfiguration { @Bean @Order(SecurityProperties.BASIC_AUTH_ORDER) SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((requests) -\u0026gt; requests.anyRequest().authenticated()); http.formLogin(withDefaults()); http.httpBasic(withDefaults()); return http.build(); } } 默认安全行为会要求所有的资源访问都需要验证, 如果我们需要自定义安全行为, 我们需要自行配置这个Bean\n7. 如何自定义Spring Security基本安全行为 新建一个Configuration 并创建一个SecurityFilterChain的Bean, 在bean中 对HttpSecurity对象定义安全规则\n子SpringSecurity6之后, 需要将链式编程优化为Lamda式编程, 具体可参考官方迁移文档\n如果只需要简单的重新时间默认安全规则, 实例配置类如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Configuration public class SpringSecurityConfig { /** * 自定义安全规则 * * @param http * @return * @throws Exception */ @Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((requests) -\u0026gt; requests.anyRequest().authenticated()); http.formLogin(formLogin -\u0026gt; {}); // shortcut for http.formLogin(Customizer.withDefaults()); http.httpBasic(Customizer.withDefaults()); return http.build(); } } 注意其中Customizer.withDefaults() 可以简化为 item -{}\n一份自定义安全规则示例\nauthenticated() permitAll() denyAll()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 自定义安全规则 */ @Configuration public class SpringSecurityConfig { /** * 自定义安全规则 所有/api端口均需要保护 * 开放/contact端口 * /notices端口不可以被任何人访问 * * @param http * @return * @throws Exception */ @Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { // 在lambda风格下定义url安全规则 http.authorizeHttpRequests((requests) -\u0026gt; { requests.requestMatchers(\u0026#34;/api/**\u0026#34;).authenticated(); requests.requestMatchers( \u0026#34;/contact\u0026#34;).permitAll(); requests.requestMatchers(\u0026#34;/notices\u0026#34;).denyAll(); }); http.formLogin(formLogin -\u0026gt; { }); http.httpBasic(Customizer.withDefaults()); return http.build(); } } 7. 如何使用服务器内存初始化多个用户 (使用默认编码器或明文密码) 在配置文件中只支持配置单个系统默认用户, 如果需要在系统中配置多个不同角色不同权限的默认用户, 可以使用内存初始化配置\n在IOC 容器中注入InMemeryUserDetailManager Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 不可以在生产环境中使用 * @return */ @Bean public InMemoryUserDetailsManager userDetailsManager() { //在生产环境中不可以使用withDefaultPasswordEncoder, 而是需要自己定义具体的PasswordEncoderBean UserDetails admin = User.withDefaultPasswordEncoder() .username(\u0026#34;admin\u0026#34;) .password(\u0026#34;admin\u0026#34;) .authorities(\u0026#34;ADMIN\u0026#34;) .build(); UserDetails user = User.withDefaultPasswordEncoder() .username(\u0026#34;user\u0026#34;) .password(\u0026#34;user\u0026#34;) .authorities(\u0026#34;USER\u0026#34;) .build(); return new InMemoryUserDetailsManager(admin, user); } 在测试和开发环境中, 我们也可以不启用密码加密, 直接使用明文密码, 实现方式如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Bean public InMemoryUserDetailsManager userDetailsManager() { InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager(); UserDetails admin = User.withUsername(\u0026#34;admin\u0026#34;).password(\u0026#34;{noop}12345\u0026#34;).authorities(\u0026#34;admin\u0026#34;).build(); UserDetails user = User.withUsername(\u0026#34;user\u0026#34;).password(\u0026#34;{noop}12345\u0026#34;).authorities(\u0026#34;read\u0026#34;).build(); inMemoryUserDetailsManager.createUser(admin); inMemoryUserDetailsManager.createUser(user); return inMemoryUserDetailsManager; } /** * NoOpPasswordEncoder is not recommended for production usage. * Use only for non-prod. * * @return PasswordEncoder */ @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } 8. Spring security用户管理接口细节 UserDetailsService（接口）：这是一个核心接口，用于通过用户名加载用户的详细信息。通常通过实现该接口的loadUserByUsername方法来从数据库或其他存储系统中检索用户信息。 UserDetailsManager（接口）：这是UserDetailsService的一个扩展，它添加了管理用户详细信息的能力，如创建、更新、删除用户以及更改密码。 InMemoryUserDetailsManager、JdbcUserDetailsManager、LdapUserDetailsManager：这些是Spring Security提供的实现UserDetailsManager接口的类，用于支持不同类型的数据存储。例如，InMemoryUserDetailsManager用于内存存储，JdbcUserDetailsManager用于通过JDBC与数据库交互，而LdapUserDetailsManager用于与LDAP服务器交互。 UserDetails：这是一个接口，所有的用户信息都会封装在实现了UserDetails的对象中，这包括用户名、密码、权限等。 9. UserDetailManager接口在SpringSecurity中的默认实现类解析 InMemeryUserDetailsManager -\u0026gt; 通过服务器内存管理静态用户\nSpringSecurity框架内已经实现了接口方法, 不需要再去编写, 都可以直接调用\nJdbcUserDetailsManager -\u0026gt; 通过数据库管理和验证系统用户\nSpringSecurity默认假设了一个数据库表结构, 并在此结构上编写了基本语句\n默认的数据库结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create table users ( id bigint primary key not null AUTO_INCREMENT, username varchar(255) not null, password varchar(255) not null, enabled boolean not null ); create table authorities ( id bigint primary key not null AUTO_INCREMENT, username varchar(255) not null, authority varchar(255) not null, user_id bigint not null, constraint fk_authorities_users foreign key (user_id) references users (id) ); Ldap\n添加支持Lapt协议的依赖\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.ldap\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ldap-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-ldap\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 10. 使用默认JdbcUserDetailsManager连接数据库进行用户验证 在AWS Cloud上新建一个Mysql数据库 在Idea中连接该AWS RDS 在项目中引入mysql驱动和Mybatis依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.33\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.30\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 使用Idea自带的Generate Persistence Mapping自动生成Jpa实体类 更新配置类 1 2 3 4 5 6 7 8 9 @Bean public UserDetailsService userDetailsService(DataSource dataSource) { return new JdbcUserDetailsManager(dataSource); } @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } 我们已经在数据库中Insert了一个明文密码用户, 因此只要我们创建一个无密码编码器的Bean, 就可以实现简单的登陆了\n11. 使用自定义的表结构进行用户登录验证 首先我们创建我们自定义的表结构\n1 2 3 4 5 6 7 8 9 10 create table customer ( id bigint not null AUTO_INCREMENT, email varchar(255) not null, pwd varchar(200) not null, role varchar(255) not null, primary key (id) ); insert into customer(email, pwd, role) values (\u0026#39;admin@gmail.com\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;admin\u0026#39;); 创建对应的Jpa实体 以及Repository接口\n自定义实现UserDetailService接口来实现自定义验证\n创建一个UserDetailService的实现类, 并实现loadUserByUsername方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service @AllArgsConstructor public class EasyBankUserDetails implements UserDetailsService { private final CustomerRepository customerRepository; @Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException { List\u0026lt;Customer\u0026gt; customers = customerRepository.findByEmail(email); if (customers.isEmpty()) { throw new UsernameNotFoundException(\u0026#34;User not found\u0026#34;); } Customer customer = customers.get(0); return new User(customer.getEmail(), customer.getPwd(), List.of(new SimpleGrantedAuthority(customer.getRole()))); } } 当我们自定义实现了UserDetailService之后, 我们需要去除之前注入的默认UserDetailService Bean, 不然会报错, 因为Spring并不知道该使用哪一个UserDetailService Bean来进行验证\n现在我们就可以使用自己自定义的表结构来进行用户登陆验证了\n12. 用户注册 对于用户注册, 我们可以实现UserDetailManager接口来通过Spring Security来协助实现注册等功能, 但是一般开发更倾向于直接使用Restful风格的API完成这些功能, 只将用户的验证和鉴权部分交给Spring Security\n具体注册逻辑实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController @AllArgsConstructor public class LoginController { private final CustomerRepository customerRepository; private final CustomerMapper customerMapper; @PostMapping(\u0026#34;/register\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; registerUser(@RequestBody RegisterUserDto registerUserDto) { try { Customer customer = customerMapper.registerUserFromDto(registerUserDto); Customer save = customerRepository.save(customer); return ResponseEntity.status(HttpStatus.CREATED).body(\u0026#34;User Created\u0026#34;); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\u0026#34;An Exception occurred due to \u0026#34; + e.getMessage()); } } } 同时我们还需要permitAll该注册接口, 并且disable csrf来允许post请求\n1 2 3 4 5 http.csrf(AbstractHttpConfigurer::disable); // 关闭CSRF 以允许服务接受POST请求 http.authorizeHttpRequests((requests) -\u0026gt; { requests.requestMatchers(\u0026#34;/api/**\u0026#34;).authenticated(); requests.requestMatchers( \u0026#34;/contact\u0026#34;, \u0026#34;/notices\u0026#34;, \u0026#34;/register\u0026#34;).permitAll(); }); 为了代码简洁, 引入mapstruct依赖\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.5.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct-processor --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-processor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.5.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 创建mapper接口\n1 2 3 4 @Mapper(componentModel = \u0026#34;spring\u0026#34;) public interface CustomerMapper { Customer registerUserFromDto(RegisterUserDto registerUserDto); } 使用Postman测试接口, 测试通过\n13. 密码编码器与解码器 Spring Security中的密码比较 是使用对应编码器的matches方法实现的\n编码 vs 加密 vs 哈希散列 编码内容是可以逆向解码出原内容的 -\u0026gt; 不适合作为密码管理方法 ASCII BASE64 UNICODE\n加密是通过特定的加密算法 + 密钥对内容进行处理的方法, 解密过程需要得到算法+密钥, 也不适合作为密码管理方法\n什么是哈希? 原数据将通过数学散列方法转换为散列值 -\u0026gt; 不可逆的\n以Bcrypt为例, 他的哈希需要提供 round值 和原内容, 生成一个哈希字符串, 优点在于, 即使是完全一样的原内容, 生成的哈希字符串的字符串值是完全不同的, 但是两个字符串的哈希值相同, 因此可以用于密码验证\nSpring Security中的PasswordEncoder接口 有两个抽象方法和一个默认方法\nencode -\u0026gt; 加密明文密码\nmatches -\u0026gt; 返回明文密码和数据库中的加密密码是否匹配\nupgradeEncoding -\u0026gt; 是否需要对密码进行二次加密 默认是false\nSpring Security中PasswordEncoder接口的实现类 NoOpPasswordEncoder -\u0026gt; 直接明文equals比对密码 StandardPasswordEncoder -\u0026gt; 本质是一个加密encoder, 不推荐现代程序使用 Pbkdf2PasswordEncoder -\u0026gt; 低强度的哈希散列Encoder, 暴力破解成本低 BCryptPasswordEncoder -\u0026gt; BCrypt哈希算法 并且定期更新 -\u0026gt; 根据轮数要求CPU计算 SCryptPasswordEncoder -\u0026gt; 进阶版的BCrypt算法 不仅对CPU有要求, 还对RAM内存有要求 Argon2PasswordEncoder -\u0026gt; 最新的哈希算法 CPU计算能力 + RAM要求 + 多线程 预防哈希暴力破解 增加密码复杂度 -\u0026gt; 鼓励使用强密码 -\u0026gt; 8位密码 + 数字 + 特殊符号\n使用更加强大的哈希算法\n在Spring Security中使用BcryptPasswordEncode 在配置类中注入该Encoder\n1 2 3 4 @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } 在注册过程中使用该Encoder对密码进行哈希后再存到数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController @AllArgsConstructor public class LoginController { private final CustomerRepository customerRepository; private final CustomerMapper customerMapper; private final PasswordEncoder bCryptEncoder; @PostMapping(\u0026#34;/register\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; registerUser(@RequestBody RegisterUserDto registerUserDto) { try { registerUserDto.setPwd(bCryptEncoder.encode(registerUserDto.getPwd())); Customer customer = customerMapper.registerUserFromDto(registerUserDto); Customer save = customerRepository.save(customer); return ResponseEntity.status(HttpStatus.CREATED).body(\u0026#34;User Created\u0026#34;); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\u0026#34;An Exception occurred due to \u0026#34; + e.getMessage()); } } } 14. 实现自定义的AuthenticationProvider 目前我们仍旧在使用Spring Security默认的DaoAuthenticationProvider\n在一个应用程序中, 我们可能需要编写多个AuthenticationProvider来满足不同的用户登录验证要求\n例如 账密 + Oauth2 + OTP多种登陆方式, 在这种情况下, 我们需要实现不同的自定义AuthenticationProvider并通过ProviderManager实现正确映射\n什么是AuthenticationProvider接口? 两个抽象方法\nAuthentication authenticate(Authentication authentication); -\u0026gt; 实现具体的验证逻辑, 最后需要返回Authentication对象, 并且注明是否验证通过\nboolean suppliers(Class\u003c?\u003e authentication); -\u0026gt; 所支持的验证方法\n如何实现自定义的AuthenticationProvider 自定义实现AuthenticationProvider接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @AllArgsConstructor @Component public class EasyBankUsernamePwdAuthenticationProvider implements AuthenticationProvider { private final CustomerRepository customerRepository; private final PasswordEncoder bCryptPasswordEncoder; /** * 自定义的用户验证逻辑 * * @param authentication the authentication request object. * @return * @throws AuthenticationException */ @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { List\u0026lt;Customer\u0026gt; byEmail = customerRepository.findByEmail(authentication.getName()); if (byEmail.isEmpty()) { throw new BadCredentialsException(\u0026#34;Username password not match\u0026#34;); } Customer customer = byEmail.get(0); if (!bCryptPasswordEncoder.matches(authentication.getCredentials().toString(), customer.getPwd())) { throw new BadCredentialsException(\u0026#34;Username password not match\u0026#34;); } return new UsernamePasswordAuthenticationToken( customer.getEmail(), authentication.getCredentials().toString(), List.of(new SimpleGrantedAuthority(customer.getRole())) ); } /** * 支持用户名密码类型的验证 * * @param authentication * @return */ @Override public boolean supports(Class\u0026lt;?\u0026gt; authentication) { return (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication)); } } 将这个Bean注入到Spring容器后, 我们就不需要之前自己实现的EasyBankUserDetails -\u0026gt; UserDetailService实现类了, 因为我们已经不在使用DaoAuthenticationProvider来进行用户验证了\n15. CORS(cross-origin resource sharing) \u0026amp; CSRF(cross-site request forgery) CORS -\u0026gt; 不是攻击或者漏洞, 只是一个浏览器安全层策略, 需要后端服务器来进行配置 当我们尝试再前端调用后端的公共接口时, 请求会抛出CORS错误 -\u0026gt; 浏览器级别错误, 请求不会到达服务器\n浏览器会默认屏蔽不同源的请求, 不同域名 或 不同端口 或 不同协议的请求及资源\n如何在前后端分离应用中解决CORS问题\n从SpringBoot后端控制器和方法级别配置\n@CrossOrigin(origins = \u0026ldquo;http://localhost:4200\u0026rdquo;)\n@CrossOrigin(origins = \u0026ldquo;*\u0026rdquo;)\n浏览器是如何知道我的后端服务器配置了跨域? 通过preflight请求\n我们也可以配置Spring Security cors config\n1 2 3 4 5 6 7 8 9 10 11 12 http.cors((cors) -\u0026gt; cors.configurationSource(new CorsConfigurationSource() { @Override public CorsConfiguration getCorsConfiguration(HttpServletRequest request) { CorsConfiguration config = new CorsConfiguration(); config.setAllowedOrigins(Collections.singletonList(\u0026#34;http://localhost:4200\u0026#34;)); // 允许跨域的源 config.setAllowedMethods(Collections.singletonList(\u0026#34;*\u0026#34;)); // 允许跨域使用的HttpMethod config.setAllowCredentials(true); // 使用允许浏览器Credential config.setAllowedHeaders(Collections.singletonList(\u0026#34;*\u0026#34;)); // 允许携带的Header config.setMaxAge(3600L); // 跨域缓存时间 在该时间内相同请求不需要再次preflight return config; } })); CSRF -\u0026gt; 网络安全攻击 Spring Security默认防护CSRF攻击的方式 是阻止所有POST PUT请求, 防止请求体携带数据, 因此在之前的开发中, 我们只是简单关闭了CSRF防护 不可以在生产环境配置\n1 http.csrf(AbstractHttpConfigurer::disable); // 关闭CSRF 以允许服务接受POST请求 因为浏览器足够只能, 在向某域名发送请求时会自动携带该域名的Cookie, 因此黑客可能会诱导用户点击诱饵连接, 并发送跨站请求到其他网站(携带用户Cookie), 并以此修改用户信息\n因此我们需要某种方法来确定请求的来源 -\u0026gt; csrf令牌, 每个用户每次会话唯一 可以由Cookie携带\n因为由安全页面发送的请求, 可以通过JS获取Cookie, 并将约定的信息放在header 或 payload中, 但是黑客网站只能通过浏览器默认行为携带Cookie, 并不能并携带额外信息\n尝试使用Spring Security实现上述基本CSRF安全防护 1 2 3 4 5 6 7 8 CsrfTokenRequestAttributeHandler csrfTokenRequestAttributeHandler = new CsrfTokenRequestAttributeHandler(); csrfTokenRequestAttributeHandler.setCsrfRequestAttributeName(\u0026#34;_csrf\u0026#34;); // default attribute name http.csrf((csrf) -\u0026gt; { csrf .csrfTokenRequestHandler(csrfTokenRequestAttributeHandler) // 配置CsrfTokenRequestHeader 也就是csrfToken的属性名 .ignoringRequestMatchers(\u0026#34;/register\u0026#34;, \u0026#34;/contact\u0026#34;) // 配置不需要CSRF防护的endpoint .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); // 配置token存放位置和读取位置 withHttpOnlyFalse适用于AngularJS }); 这样Spring Security就可以自动实现csrfToken的存放和读取了, 但是我们还需要让UI程序获得后端生成的csrfToken, 所以我们需要使用一个过滤器来为每个响应携带csrfToken\n创建一个filter 虽然我们只是在代码中将csrfToken天机到了Header中, 但是SpringSecurity会自动为浏览器生成CSRF Cookie\n1 2 3 4 5 6 7 8 9 10 public class CsrfCookieFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { CsrfToken csrfToken = (CsrfToken)request.getAttribute(CsrfToken.class.getName()); // 从请求中获取CsrfToken if (null != csrfToken.getHeaderName()) { response.setHeader(csrfToken.getHeaderName(), csrfToken.getToken()); // 为返回值设置CsrfToken header } filterChain.doFilter(request, response); // 继续过滤器链 } } 然后将该过滤器添加到SpringSecurity过滤器链中\n1 http.addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class); // 将自定义的csrfToken过滤器添加到SpringSecurity过滤器链中 为了实现前后端分离的用户验证, 也需要修改如下配置\n1 2 3 4 5 6 http.securityContext((context) -\u0026gt; { context.requireExplicitSave(false); //表示不需要显式地调用来保存安全上下文（Security Context） }); http.sessionManagement((session) -\u0026gt; { session.sessionCreationPolicy(SessionCreationPolicy.ALWAYS); //表示 Spring Security 应该总是创建 HttpSession 实例 }); 调整前端Angular代码以实现CSRF防护 在Login Component中, 从登录成功的请求中读取CSRF Cookie, 存储到session storage, 并准备为之后的请求都携带该csrf token\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 validateUser(loginForm: NgForm) { this.loginService.validateLoginDetails(this.model).subscribe( responseData =\u0026gt; { this.model = \u0026lt;any\u0026gt; responseData.body; // 从相应中获取CSRF Cookie并为之后的请求都携带该CSRF Token let xsrf = getCookie(\u0026#39;XSRF-TOKEN\u0026#39;)!; window.sessionStorage.setItem(\u0026#39;XSRF-TOKEN\u0026#39;, xsrf); this.model.authStatus = \u0026#39;AUTH\u0026#39;; window.sessionStorage.setItem(\u0026#34;userdetails\u0026#34;,JSON.stringify(this.model)); this.router.navigate([\u0026#39;dashboard\u0026#39;]); }); } 在拦截器中, 为每次请求, 都从该session storage中取出该token, 并由header携带\n1 2 3 4 5 // 从session storage 中取出csrf token并放置在Header中 let xsrf = sessionStorage.getItem(\u0026#39;XSRF-TOKEN\u0026#39;); if (xsrf) { httpHeaders = httpHeaders.append(\u0026#39;X-XSRF-TOKEN\u0026#39;, xsrf); } 需要确保前端和后端服务的context-path一致, 或者手动将Cookie Path设置为 root /, 不然前端还是没有办法读取该XSRF-TOKEN cookie的\n16. 用户权限验证 初始化权限表authorities, 并初始化权限数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE `authorities` ( id int not null auto_increment, customer_id int not null, name varchar(50) not null, primary key (id), key customer_id (customer_id), constraint authorities_customer_fk foreign key (customer_id) references customer (customer_id) ); INSERT INTO authorities(customer_id, name) values (1, \u0026#39;VIEWACCOUNT\u0026#39;); INSERT INTO authorities(customer_id, name) values (1, \u0026#39;VIEWCARDS\u0026#39;); INSERT INTO authorities(customer_id, name) values (1, \u0026#39;VIEWLOANS\u0026#39;); INSERT INTO authorities(customer_id, name) values (1, \u0026#39;VIEWBALANCE\u0026#39;); 后端实体与代码\n修改自定义的AuthenticationProvider代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { List\u0026lt;Customer\u0026gt; byEmail = customerRepository.findByEmail(authentication.getName()); if (byEmail.isEmpty()) { throw new BadCredentialsException(\u0026#34;Username password not match\u0026#34;); } Customer customer = byEmail.get(0); if (!bCryptPasswordEncoder.matches(authentication.getCredentials().toString(), customer.getPwd())) { throw new BadCredentialsException(\u0026#34;Username password not match\u0026#34;); } return new UsernamePasswordAuthenticationToken( customer.getEmail(), authentication.getCredentials().toString(), getGrantedAuthorities(customer.getAuthorities()) ); } private List\u0026lt;GrantedAuthority\u0026gt; getGrantedAuthorities(Set\u0026lt;Authority\u0026gt; authorities) { List\u0026lt;GrantedAuthority\u0026gt; grantedAuthorities = new ArrayList\u0026lt;\u0026gt;(); for (Authority authority: authorities ) { grantedAuthorities.add(new SimpleGrantedAuthority(authority.getName())); } return grantedAuthorities; } 常用的权限认证方法 hasAuthority() -\u0026gt; 查验单个权限\nhasAnyAuthority() -\u0026gt; 查验是否拥有多个权限中的任意一个\naccess() -\u0026gt; 使用Spring Expression Language实现复杂权限验证\n在Spring security配置类中实现endpoint权限验证\n更新spring security配置\n1 2 3 4 5 6 7 8 http.authorizeHttpRequests((requests) -\u0026gt; { requests.requestMatchers(\u0026#34;/api/myAccount\u0026#34;).hasAuthority(\u0026#34;VIEWACCOUNT\u0026#34;); requests.requestMatchers(\u0026#34;/api/myBalance\u0026#34;).hasAnyAuthority(\u0026#34;VIEWBALANCE\u0026#34;, \u0026#34;VIEWACCOUNT\u0026#34;); requests.requestMatchers(\u0026#34;/api/myLoans\u0026#34;).hasAuthority(\u0026#34;VIEWLOANS\u0026#34;); requests.requestMatchers(\u0026#34;/api/myCards\u0026#34;).hasAuthority(\u0026#34;VIEWCARDS\u0026#34;); requests.requestMatchers( \u0026#34;/user\u0026#34;).authenticated(); requests.requestMatchers(\u0026#34;/notices\u0026#34;, \u0026#34;/register\u0026#34;, \u0026#34;/contact\u0026#34;).permitAll(); }); 基于角色的权限认证方法 Spring security的Role 必须是\u0026quot;ROLE_xxx\u0026quot;的格式\n先更新数据库中的数据, 将权限更改为角色\n1 2 3 4 delete from authorities; insert into authorities(customer_id, name) values(1, \u0026#39;ROLE_USER\u0026#39;); insert into authorities(customer_id, name) values(1, \u0026#39;ROLE_ADMIN\u0026#39;); 常见的角色认证方法\nhasRole()\nhasAnyRole()\naccess()\n在数据库中我们的角色是有前缀的, 但是在方法中 不需要加前缀\n1 2 3 4 5 6 7 8 http.authorizeHttpRequests((requests) -\u0026gt; { requests.requestMatchers(\u0026#34;/api/myAccount\u0026#34;).hasRole(\u0026#34;USER\u0026#34;); requests.requestMatchers(\u0026#34;/api/myBalance\u0026#34;).hasAnyRole(\u0026#34;USER\u0026#34;, \u0026#34;ADMIN\u0026#34;); requests.requestMatchers(\u0026#34;/api/myLoans\u0026#34;).hasRole(\u0026#34;USER\u0026#34;); requests.requestMatchers(\u0026#34;/api/myCards\u0026#34;).hasRole(\u0026#34;USER\u0026#34;); requests.requestMatchers( \u0026#34;/user\u0026#34;).authenticated(); requests.requestMatchers(\u0026#34;/notices\u0026#34;, \u0026#34;/register\u0026#34;, \u0026#34;/contact\u0026#34;).permitAll(); }); 17. Spring Security 过滤器 如何展示一些内置过滤器 -\u0026gt; 17个\n在启动类中@EnableWebSecurity(debug=true)\n在application.yml 中配置 logging.level.org.springframework.security.web.FilterChainProxy = Debug\n1 2 3 4 5 6 7 logging: level: org: springframework: security: web: FilterChainProxy: Debug 如何自定义过滤器 实现Filter接口中的doFilter方法, 并在SpringSecurity配置文件中使用\naddFilterBefore() -\u0026gt; 在指定过滤器前执行该过滤器\naddFilterAfter() -\u0026gt; 在指定过滤器后执行该过滤器\naddFilterAt() -\u0026gt; 在指定过滤器前或后执行该过滤器\n其他高级选项\n抽象类GenericFilterBean 会提供你配置的参数\n抽象类OncePerRequestFilter 每个请求只会执行一次的Filter, 正常情况下Filter并不能保证一次请求只执行一次. 逻辑需要实现在doFilterInternal()方法中\nshouldNotFilter() 通过实现这个方法来实现只在特定Request中调用这个Filter\n18. 高级认证方式 传统Cookie方式JsessionId的使用与问题\nSpring Security每次为用户自动生成的Cookie, 前端的每次请求都会携带该Cookie, 因此后端不需要为认证过用户的请求再次进行认证\n但是这种Cookie方式, 基本上只适用于小型应用, 对于大型的微服务应用, 多服务间的数据共享 只凭JsessionId是无法满足的, 他无法携带更多数据, 并且他是基于用户会话的\nToken -\u0026gt; 用户第一次登录成功后生成, 生成后每次请求都会携带, 后端会验证Token的有效性\nJson Web Token\nJWT由三部分组成 每部分之间由 . 分割\nheader -\u0026gt; Token元数据, 加密方法 类型 等 -\u0026gt; base64编码 payload -\u0026gt; 用户数据 发布者等-\u0026gt; base64编码 signature (optional) 后端会把JWTtoken存在数据库中, 但是通过签名, 可以避免存储 一般是SHA256 或者 HMAC\n数字签名部分是基于密钥, 以及Header 和 Body部分生成的Hash字符串, 每次验证时, 后端将传入的Header Body和存储在后端的密钥 再次Hash, 对比两次签名是否一致\n如果Header body经过篡改, 那么签名的哈希值就不会一致\n如何在项目中使用JWT登录 添加maven依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 修改原先的SpringSecurity配置类\n取消JsessionId的生成, 也不再保存会话信息, 设置Session生成策略为无状态\n1 2 3 http.sessionManagement(management -\u0026gt; { management.sessionCreationPolicy(SessionCreationPolicy.STATELESS); }); 调整CORS策略, 暴露相应的Authorication header, 用于发送JWT给前端\n1 2 3 4 5 6 7 8 9 10 11 12 13 http.cors((cors) -\u0026gt; cors.configurationSource(new CorsConfigurationSource() { @Override public CorsConfiguration getCorsConfiguration(HttpServletRequest request) { CorsConfiguration config = new CorsConfiguration(); config.setAllowedOrigins(Collections.singletonList(\u0026#34;http://localhost:4200\u0026#34;)); // 允许跨域的源 config.setAllowedMethods(Collections.singletonList(\u0026#34;*\u0026#34;)); // 允许跨域使用的HttpMethod config.setAllowCredentials(true); // 使用允许浏览器Credential config.setAllowedHeaders(List.of(\u0026#34;*\u0026#34;)); // 允许传入的Header config.setExposedHeaders(List.of(\u0026#34;Authorization\u0026#34;)); // 允许暴露给前端的Header config.setMaxAge(3600L); // 跨域缓存时间 在该时间内相同请求不需要再次preflight return config; } })); 实现首次登陆时生成JWT 配置一个contrants, 用于存放secret 和请求头名\n1 2 3 4 5 6 7 public interface SecurityConstants { /** * Key with 256 bits long as required for HMAC-SHA algorithms according to the JWT JWA Specification */ public static final String JWT_KEY = \u0026#34;920c89ec967c247811f81054c284d2357e49f94a8342f0a7820b1f93b6f8c151\u0026#34;; public static final String JWT_HEADER = \u0026#34;Authorization\u0026#34;; } 配置JWT生成过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class JWTGeneratorFilter extends OncePerRequestFilter { /** * 生成JWT * @param request * @param response * @param filterChain * @throws ServletException * @throws IOException */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { Date now = new Date(); Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (null != authentication) { SecretKey secretKey = Keys.hmacShaKeyFor(SecurityConstants.JWT_KEY.getBytes(StandardCharsets.UTF_8)); String jwt = Jwts.builder().setIssuer(\u0026#34;XYC\u0026#34;).setSubject(\u0026#34;JsonWebToken\u0026#34;) .claim(\u0026#34;username\u0026#34;, authentication.getName()) .claim(\u0026#34;authorities\u0026#34;, populateAuthorities(authentication.getAuthorities())) .setIssuedAt(now) .setExpiration(new Date(now.getTime() + 30000000)) .signWith(secretKey).compact(); response.setHeader(SecurityConstants.JWT_HEADER, jwt); } filterChain.doFilter(request, response); } /** * 只有 /user的登录请求才会生成JWT * @param request current HTTP request * @return */ @Override protected boolean shouldNotFilter(HttpServletRequest request) { System.out.println(request.getServletPath()); return !request.getServletPath().equals(\u0026#34;/user\u0026#34;); } private String populateAuthorities(Collection\u0026lt;? extends GrantedAuthority\u0026gt; collection) { Set\u0026lt;String\u0026gt; authoritiesSet = new HashSet\u0026lt;\u0026gt;(); collection.forEach(item -\u0026gt; authoritiesSet.add(item.getAuthority())); return String.join(\u0026#34;,\u0026#34;, authoritiesSet); } } 在SecurityConfig中将该过滤器添加到过滤器链中, 但是要在身份验证成功之后\n1 2 3 4 5 6 7 8 http.csrf((csrf) -\u0026gt; { csrf .csrfTokenRequestHandler(csrfTokenRequestAttributeHandler) // 配置CsrfTokenRequestHeader 也就是csrfToken的属性名 .ignoringRequestMatchers(\u0026#34;/register\u0026#34;, \u0026#34;/contact\u0026#34;) // 配置不需要CSRF防护的endpoint .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); // 配置token存放位置和读取位置 withHttpOnlyFalse适用于AngularJS }).addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class);// 将自定义的csrfToken过滤器添加到SpringSecurity过滤器链中 // 身份验证通过后才会生成JWT http.addFilterAfter(new JWTGeneratorFilter(), BasicAuthenticationFilter.class); 配置JWT验证过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class JWTValidatorFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String jwt = request.getHeader(SecurityConstants.JWT_HEADER); if (null != jwt) { try { SecretKey secretKey = Keys.hmacShaKeyFor(SecurityConstants.JWT_KEY.getBytes(StandardCharsets.UTF_8)); Claims claims = Jwts.parserBuilder() .setSigningKey(secretKey) .build() .parseClaimsJws(jwt) .getBody(); String username = String.valueOf(claims.get(\u0026#34;username\u0026#34;)); String authorities = (String)claims.get(\u0026#34;authorities\u0026#34;); Authentication authentication = new UsernamePasswordAuthenticationToken(username, null, AuthorityUtils.commaSeparatedStringToAuthorityList(authorities)); SecurityContextHolder.getContext().setAuthentication(authentication); } catch (Exception e) { throw new BadCredentialsException(\u0026#34;Invalid Token Received\u0026#34;); } } filterChain.doFilter(request, response); } @Override protected boolean shouldNotFilter(HttpServletRequest request) { return request.getServletPath().equals(\u0026#34;/user\u0026#34;); } } 将该过滤器添加到过滤器链中\n1 2 3 4 // 身份验证通过后才会生成JWT http.addFilterAfter(new JWTGeneratorFilter(), BasicAuthenticationFilter.class); // 对非登录请求, 先验证JWT http.addFilterBefore(new JWTValidatorFilter(), BasicAuthenticationFilter.class); 实现前端请求携带JWT 在登录请求中, 收到相应后, 将JWT Token存到SessionStorage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 validateUser(loginForm: NgForm) { this.loginService.validateLoginDetails(this.model).subscribe( responseData =\u0026gt; { // 存储响应所返回的JWT window.sessionStorage.setItem(\u0026#34;Authorization\u0026#34;, responseData.headers.get(\u0026#34;Authorization\u0026#34;)!); this.model = \u0026lt;any\u0026gt; responseData.body; console.log(responseData.headers.get(\u0026#39;X-Xsrf-Token\u0026#39;)); this.model.authStatus = \u0026#39;AUTH\u0026#39;; window.sessionStorage.setItem(\u0026#34;userdetails\u0026#34;,JSON.stringify(this.model)); let xsrf = this.cookieService.get(\u0026#34;XSRF-TOKEN\u0026#34;)!; console.log(xsrf) window.sessionStorage.setItem(\u0026#34;XSRF-TOKEN\u0026#34;,xsrf); this.router.navigate([\u0026#39;dashboard\u0026#39;]); }); } 在拦截器中, 为发出的请求添加JWT\n对于登录请求, 我们不发送JWT\n对于非登录请求, 从SessionStorage中取出JWT并添加请求头\n1 2 3 4 5 6 7 8 if(this.user \u0026amp;\u0026amp; this.user.password \u0026amp;\u0026amp; this.user.email){ httpHeaders = httpHeaders.append(\u0026#39;Authorization\u0026#39;, \u0026#39;Basic \u0026#39; + window.btoa(this.user.email + \u0026#39;:\u0026#39; + this.user.password)); } else { let authorization = sessionStorage.getItem(\u0026#39;Authorization\u0026#39;); if (authorization) { httpHeaders = httpHeaders.append(\u0026#39;Authorization\u0026#39;, authorization); } } 19. Spring Security 方法级鉴权 默认是未开启的, 需要在配置类或者启动类中加入注解@EnableMethodSecurity\n在URL和权限角色认证之后的第二级安全措施\n@EnableMethodSecurity(prePostEnabled=true, securedEnabled = true, jsr250Enabled = true)\n推荐 prePostEnabled -\u0026gt; 可以使用 @PreAuthorize 和 @PostAuthorize 可以接受SpringExpression\nsecuredEnable -\u0026gt; 可以使用 @Secured\njsr250Enabled -\u0026gt; 可以使用@RollAllowed\n如何实现@PreAuthorize 1 requests.requestMatchers(\u0026#34;/api/myLoans\u0026#34;).authenticated(); 1 @EnableMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true) 1 2 @PreAuthorize(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) List\u0026lt;Loans\u0026gt; findByCustomerOrderByStartDtDesc(Customer customer); 同理可以实现@PostAuthorize, 区别是PostAuthorize会导致方法执行, 在方法返回前进行鉴权, 如果不满足, 则不发送结果\n@PreFilter注解, 可以过滤方法的传入参数, 但是需要保证传入参数是一个集合\n@PostFilter注解, 可以过滤方法的返回结果, 但是需要保证返回结果是一个集合\n20. Oauth2 Oauth2鼓励使用单独的服务进行用户登录和权限认证\n术语:\nResouce Owner: 客户端用户 最后资源的所有者\nClient: 第三方应用 最终资源的需求者\nAuthorization Server: 认证服务器, Resource Own用户认证服务器\nResource Server: 最终资源服务器\nScopes: Client所需要的权限范围\nClient需要先在Authorization Server上注册Client Id 和Client Secret\n具体实现待补充\u0026hellip;\u0026hellip;\n","date":"2024-10-07T00:00:00Z","image":"https://ProfGamer.github.io/p/spring-security-6-%E7%AC%94%E8%AE%B0/spring-security-6_hu9554448748335546872.jpg","permalink":"https://ProfGamer.github.io/p/spring-security-6-%E7%AC%94%E8%AE%B0/","title":"Spring Security 6 笔记"}]